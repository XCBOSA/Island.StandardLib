# Island.StandardLib.MapGenerator
建议此namespace下的代码编译为独立的dll，防止过于臃肿。  
众所周知（也许吧），地图生成器只需要实现一个函数：h=f(x,y)，且(1) f(x,y)非递归定义，即不依赖f(x-1,y-1)，(2) f(x,y)连续（当然，不用真的去求导，上色求梯度的时候是离散的，f(x+1,y+1)-f(x,y)即可）。这看起来很简单，实际也很简单。著名游戏MC也是这样，只不过mc的h是一个长为256的序列，代表这个(x,z)上的256个方块ID。  
这一切都要感谢 Ken Perlin 发明的柏林噪声算法。为了表示敬仰，以下对柏林噪声函数简称 v=plnb(x,y,z)  
## 1. 高度图 (Height map，简称HMP) 部分  
在这里使用XXXXX3D和XX4等等游戏引擎常用的左手坐标系，这两个引擎的X轴和Z轴是反的，但是也没关系，不影响，记作我们要创作的HMP函数为 y=f(x,z)  
### 1. 群系(BIOME)图  
很好想到，如果直接令h=plnb(x,z,seedf)，生成的HMP是连绵起伏-连绵起伏-连绵起伏...没有任何区别，在现实中的地形是有平原、山地、海洋的，所以这肯定不行。  
（注：plnb采用三维柏林噪声函数，要生成二维的，所以有一个维度闲置了，不过正好可以用来当作种子。为了让seedf的离散程度很高，这里用new Random(given_seed).Next()来生成真正的seedf）  
群系图也使用plnb函数生成，使用biome[i]=plnb(x*scale, y*scale, seedf_biome[i])，有几个群系生成几次（注意这里的seedf_biome数组是开始之前生成的，为确保这些数字不线性相关，使用带seed的Random即可）  
那么这个biome数组就能用了吗？当然不能。因为这个序列现在的差异通常很小，但是在现实中平原和山地的区别很大，所以需要放大差异。放大差异采用 biome[i]=pow(1/biome[i], sharpness)。1/x^n足够用来放大差异了。  
为了方便后续使用，这里定义一个对集合的运算lnorm(collection)，此运算可以称作对集合线性归一化(linear-normalize)，缩放集合以使它们所有元素的和为1。很容易实现（但是后续非常常用），也可使用Island.StandardLib.Math中写好的Percentage类。  
对biome进行lnorm后即可得到群系图，绘制biome可以发现它非常均匀，边界清晰，是我们想要的样子。
### 2. 抽象群系
对每个生成群系执行运算...(github的md不能写公式）  
f(x,z) = E(i=0...n) biome_func[i](x,z) * biome[i] 即可  
其实就是求和，上一步已经分配好了权重，按权求和即可。  
写到这里应该已经能想到下一步要做什么了，所以简单写了。在图形学中的所见即所得，我觉得也可以带到这里，之后的很多东西需要高频的调试和瞎XX猜的公式，不需要理解这到底是什么数学原理，只需要知道它很好用，可以用（数学带师除外）。  
### 3. 更真实的一些方向
山谷和山脊的平坦都是由于流水侵蚀的作用，所以这里可以用plnb函数模拟一个线图，在线图的高点处降低生成山脉群系的plnb迭代次数。但是这个线图的种子一定要跟山脉群系一致，再进行一定的偏移筛选捕获山脉和山谷，难点是不能完全一致，否则就高次的迭代就没有意义了。时刻记住f(x,y)不能依赖f(x-1,y-1)，所以根据梯度判断是否为山脊和山谷是非常不可行的，梯度不能在生成HMP的时候求。
